import torch
import torch.nn as nn
import torch.optim as optim
import matplotlib.pyplot as plt
from torchvision.datasets import ImageFolder
from torch.utils.data import DataLoader
import torchvision.models as models
from torchvision import transforms
import os
import numpy as np

def train_epochs(net, train_loader, device, loss_function, optimizer, scheduler, epochs, start_epoch=1):
    for epoch in range(start_epoch, start_epoch + epochs):
        net.train()
        running_loss = 0.0
        for inputs, labels in train_loader:
            inputs, labels = inputs.to(device), labels.to(device)
            optimizer.zero_grad()
            outputs = net(inputs)
            loss = loss_function(outputs, labels)
            loss.backward()
            optimizer.step()
            running_loss += loss.item()
        if scheduler is not None:
            scheduler.step()
        print(f"[{epoch}] loss: {running_loss/len(train_loader):.4f}")

def main():
    device = torch.device("cpu")
    if torch.cuda.is_available():
        device = torch.device("cuda")
    elif torch.backends.mps.is_built() and torch.backends.mps.is_available():
        device = torch.device("mps")
    print(device)

    BASE_DIR = os.path.dirname(os.path.abspath(__file__))
    TRAIN_COUNTRIES_DIR = os.path.join(BASE_DIR, "trainCountries")
    TEST_COUNTRIES_DIR = os.path.join(BASE_DIR, "testCountries")

    weights = models.ResNet18_Weights.DEFAULT
    mean, std = weights.transforms().mean, weights.transforms().std

    train_transform = transforms.Compose([
        transforms.Resize(256),
        transforms.RandomResizedCrop(224),
        transforms.RandomHorizontalFlip(),
        transforms.RandomApply([transforms.ColorJitter(0.3, 0.3, 0.3, 0.1)], p=0.8),
        transforms.ToTensor(),
        transforms.Normalize(mean, std),
    ])

    test_transform = transforms.Compose([
        transforms.Resize(256),
        transforms.CenterCrop(224),
        transforms.ToTensor(),
        transforms.Normalize(mean, std),
    ])

    train_dataset = ImageFolder(root=TRAIN_COUNTRIES_DIR, transform=train_transform)
    test_dataset = ImageFolder(root=TEST_COUNTRIES_DIR, transform=test_transform)

    train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True, num_workers=0)
    test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False, num_workers=0)

    num_classes = len(train_dataset.classes)

    net = models.resnet18(weights=weights)
    net.fc = nn.Linear(net.fc.in_features, num_classes)
    net = net.to(device)

    loss_function = nn.CrossEntropyLoss()

    for p in net.parameters():
        p.requires_grad = False
    for p in net.fc.parameters():
        p.requires_grad = True

    optimizer = optim.Adam(net.fc.parameters(), lr=1e-3)
    scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=3, gamma=0.1)
    train_epochs(net, train_loader, device, loss_function, optimizer, scheduler, epochs=5, start_epoch=1)

    for p in net.layer4.parameters():
        p.requires_grad = True

    optimizer = optim.Adam(filter(lambda p: p.requires_grad, net.parameters()), lr=1e-4)
    scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=5, gamma=0.1)
    train_epochs(net, train_loader, device, loss_function, optimizer, scheduler, epochs=15, start_epoch=6)

    correct = 0
    total = 0
    net.eval()
    with torch.no_grad():
        for images, labels in test_loader:
            images, labels = images.to(device), labels.to(device)
            outputs = net(images)
            predicted = outputs.argmax(dim=1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

    print(f"Accuracy of the network: {100 * correct / total:.2f}%")

if __name__ == "__main__":
    main()
